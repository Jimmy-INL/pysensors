import numpy as np

class CCQR:
    """
    Greedy cost-constrained QR optimizer for sensor selection.
    """

    def __init__(self):
        self.p_ = None

    def get_sensors(self, basis_matrix, **optimizer_kws, cost_function):
        """
        Parameters
        ----------
        basis_matrix: np.ndarray, shape [n_features, n_samples]
            Matrix whose columns are the basis vectors in which to
            represent the measurement data.
        optimizer_kws: dictionary, optional
            Keyword arguments to be passed to the qr method.
        cost_function: Cost function on sensor location, shape [n_features, 1]
        """

#TODO: Translate code from Matlab to Python

        basis_matrixT = basis_matrix.conj().T
        m, n = basis_matrixT.shape

if len(cost_function) != n:
    raise ValueError(
                f"vector of costs has wrong dimensions"
            )

# initialize

QH = np.zeros([m,n])
R = basis_matrixT
p = range(n)

#The below needs to be translated to Python

k = min(m,n)

for j in range(k)
    u, ipiv = qrpc_reflector(np.array(R[j:m-1,j:n-1]),np.array(cost_function[p[j:n-1]]))
    # track column pivots
    ipiv = ipiv+j
    itemp = p[j]
    p[j] = p[ipiv]
    p[ipiv] = itemp
    # switch columns
    temp = R[:,j]
    R[:,j] = R[:,ipiv]
    R[:,ipiv] = temp
    # apply reflector
    QH[j:m-1,j] = u
    R[j:m-1,j:n-1] = R[j:m-1,j:n-1] - u*(u.T*R[j:m-1,j:n-1])
    R[j+1:m-1,j] = 0
    
    
     return self.p


def qrpc_reflector(r,cost_function):
    """
    QRPC_REFLECTOR best reflector with column pivoting and a cost function
 
    This function generates a Householder reflector
    The pivoting is biased by a cost function, i.e.
    the pivot is chosen as the argmax of norm(r(:,i))-cost_function(i)
    """

    # size of each column
    r2 = np.multiply(r,r)
    sum_r2 = r2.sum(axis=0)
    dlens = np.sqrt(sum_r2)

    # choose pivot
    ipiv = np.argmax(dlens-cost_function)

    dlen = dlens[ipiv]

    if dlen > 0.0:
        u = r[:,ipiv]/dlen
        u[1] = u[1] + np.sign(u[1]) + (u[1] == 0) #Not sure what the last piece is doing, or how to do it in Python
        u = u/np.sqrt(abs(u[1]))
    else:
        u = r[:,ipiv]
        u[1] = sqrt(2.0)

    return u, ipiv

       
